<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Trust Gap in Agentic Delegation</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,wght@0,400;0,600;0,700;1,400&family=Source+Code+Pro:wght@400;500&family=Source+Sans+3:wght@400;600&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Source Serif 4', Georgia, 'Times New Roman', serif;
    font-size: 20px;
    line-height: 1.72;
    color: #242424;
    background: #fff;
    -webkit-font-smoothing: antialiased;
  }

  .article {
    max-width: 680px;
    margin: 0 auto;
    padding: 40px 20px 80px;
  }

  h1 {
    font-family: 'Source Serif 4', Georgia, serif;
    font-size: 40px;
    font-weight: 700;
    line-height: 1.2;
    letter-spacing: -0.5px;
    margin-bottom: 8px;
    color: #1a1a1a;
  }

  .subtitle {
    font-family: 'Source Sans 3', Helvetica, Arial, sans-serif;
    font-size: 20px;
    font-weight: 400;
    color: #6b6b6b;
    line-height: 1.5;
    margin-bottom: 32px;
  }

  .meta {
    font-family: 'Source Sans 3', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #6b6b6b;
    margin-bottom: 32px;
    padding-bottom: 16px;
    border-bottom: 1px solid #e6e6e6;
  }

  h2 {
    font-family: 'Source Sans 3', Helvetica, Arial, sans-serif;
    font-size: 24px;
    font-weight: 700;
    line-height: 1.3;
    margin-top: 48px;
    margin-bottom: 8px;
    color: #1a1a1a;
    letter-spacing: -0.2px;
  }

  p {
    margin-bottom: 24px;
  }

  a {
    color: #1a8917;
    text-decoration: underline;
    text-underline-offset: 2px;
  }

  a:hover {
    color: #0d6e0d;
  }

  strong {
    font-weight: 600;
  }

  code {
    font-family: 'Source Code Pro', Menlo, Monaco, 'Courier New', monospace;
    font-size: 16px;
    background: #f5f5f5;
    padding: 2px 6px;
    border-radius: 3px;
    color: #1a1a1a;
  }

  ol {
    margin-bottom: 24px;
    padding-left: 30px;
  }

  ol li {
    margin-bottom: 16px;
    padding-left: 4px;
  }

  .diagram-container {
    margin: 36px 0;
    text-align: center;
  }

  .diagram-container img {
    max-width: 100%;
    height: auto;
  }

  .diagram-caption {
    font-family: 'Source Sans 3', Helvetica, Arial, sans-serif;
    font-size: 14px;
    color: #6b6b6b;
    margin-top: 12px;
    text-align: center;
    font-style: italic;
  }

  .separator {
    text-align: center;
    margin: 40px 0;
    color: #ccc;
    font-size: 24px;
    letter-spacing: 12px;
  }

  .series-note {
    font-family: 'Source Sans 3', Helvetica, Arial, sans-serif;
    font-size: 16px;
    line-height: 1.6;
    color: #6b6b6b;
    font-style: italic;
    margin-top: 40px;
    padding-top: 24px;
    border-top: 1px solid #e6e6e6;
  }

  .disclosure {
    font-family: 'Source Sans 3', Helvetica, Arial, sans-serif;
    font-size: 14px;
    line-height: 1.6;
    color: #999;
    font-style: italic;
    margin-top: 16px;
  }

  blockquote {
    border-left: 3px solid #242424;
    padding-left: 20px;
    margin: 24px 0;
    font-style: italic;
    color: #555;
  }

  .callout {
    background: #f9f9f9;
    border-left: 3px solid #1a8917;
    padding: 20px 24px;
    margin: 32px 0;
    border-radius: 0 4px 4px 0;
  }

  .callout p {
    margin-bottom: 12px;
    font-size: 18px;
  }

  .callout p:last-child {
    margin-bottom: 0;
  }
</style>
</head>
<body>
<article class="article">

<h1>The Trust Gap in Agentic Delegation</h1>
<p class="subtitle">How the industry's zero-trust vision for AI agents outpaces the standards that are supposed to secure them</p>

<div class="meta">
  <!-- [Your name] &middot; Feb 2026 &middot; 6 min read -->
</div>

<p>Last week, Red Hat published a <a href="https://next.redhat.com/2026/02/26/zero-trust-for-autonomous-agentic-ai-systems-building-more-secure-foundations/">compelling piece</a> on applying zero-trust principles to autonomous agentic AI systems. The core argument: as AI agents make access requests, fetch data, and orchestrate other agents, every hop in the chain needs explicit identity, scoped authorization, and auditability. No more implicit trust through forwarded tokens or shared API keys.</p>

<p>They're right. And they're not alone. The industry is converging on a model where each agent-to-agent delegation uses OAuth 2.0 Token Exchange (<a href="https://www.rfc-editor.org/rfc/rfc8693.html">RFC 8693</a>) to produce short-lived, scoped tokens with <code>act</code> claims that preserve the full delegation chain. WSO2 is building this into their Identity Server. Microsoft's Entra ID has been working through related challenges. The IETF OAuth working group has active drafts on <a href="https://datatracker.ietf.org/doc/draft-ietf-oauth-identity-chaining/">identity chaining across domains</a> and <a href="https://datatracker.ietf.org/doc/draft-oauth-ai-agents-on-behalf-of-user/">on-behalf-of flows for AI agents</a>.</p>

<p>The vision is sound. But there's a gap between the vision and what the current specifications actually guarantee at the exchange boundary.</p>

<h2>The Model Everyone Is Building Toward</h2>

<p>The architecture looks like this: a user authorizes an orchestrator agent, which delegates to downstream agents, each receiving a token scoped for its specific task. At every hop, the authorization server validates the delegation and issues a new token with an <code>act</code> claim recording who is acting on behalf of whom.</p>

<div class="diagram-container">
  <img src="diagram1.png" alt="Sequence diagram showing proper delegated token exchange: User authorizes Agent A, which exchanges its token for a scoped token targeting Agent B, preserving the delegation chain via act claims">
  <p class="diagram-caption">Figure 1: The intended delegation model. Each hop produces a scoped, short-lived token with an <code>act</code> claim preserving the chain of authority.</p>
</div>

<p>This is what RFC 8693 was designed for. Section 2.1 defines the <code>actor_token</code> parameter. Section 4.1 defines the <code>act</code> claim for recording delegation chains. Section 4.4 defines <code>may_act</code> for pre-authorizing specific actors.</p>

<p>Red Hat's article describes this model in detail&mdash;delegated token exchange, audience scoping, short lifetimes, continuous verification. It's the right design.</p>

<h2>Where the Standards Fall Short</h2>

<p>Here's the problem: RFC 8693 defines the <em>parameters</em> for delegation but not the <em>validation rules</em> that make delegation secure.</p>

<p>The specification tells an authorization server to accept a <code>subject_token</code> (representing the user's identity and authority) alongside an <code>actor_token</code> (representing the agent requesting to act). It describes how to encode the resulting delegation in an <code>act</code> claim. But it does not require the authorization server to verify that these two tokens belong to the same delegation context.</p>

<div class="diagram-container">
  <img src="diagram2.png" alt="Sequence diagram showing the validation gap: a malicious agent presents a subject_token from one chain with its own actor_token from a different chain, and the authorization server accepts both because it validates them independently">
  <p class="diagram-caption">Figure 2: The validation gap. The authorization server checks each token independently but never verifies they belong to the same delegation flow.</p>
</div>

<p>This means an authorization server that implements RFC 8693 as written can correctly process a token exchange request where the <code>subject_token</code> comes from one delegation chain and the <code>actor_token</code> comes from a completely different chain. The resulting token would carry an <code>act</code> claim that looks structurally valid but represents a delegation relationship that was never authorized.</p>

<p>What's missing is a binding between the two tokens. The spec does not require the authorization server to verify that the <code>subject_token</code> was issued <em>for</em> the actor presenting it&mdash;for example, by checking that the token's intended audience matches the actor's identity. Without that check, the server validates each token independently but never confirms they belong to the same delegation flow. It's checking both tickets are genuine, but not that they're for the same journey.</p>

<p>The <code>may_act</code> claim (Section 4.4) helps&mdash;it lets the subject pre-authorize specific actors. But <code>may_act</code> validates identity, not context. An agent that is legitimately authorized to act on behalf of a user in one workflow could present that authorization in a different workflow where it shouldn't apply.</p>

<p>I've raised this gap with the IETF OAuth working group and am actively working with the co-authors of <a href="https://datatracker.ietf.org/doc/draft-oauth-ai-agents-on-behalf-of-user/">draft-oauth-ai-agents-on-behalf-of-user</a> on mitigations. The engagement has been productive. But the gap exists today, in a specification that the industry is building on for securing agentic AI.</p>

<h2>Why This Matters Now</h2>

<p>This isn't a theoretical concern for three reasons.</p>

<p><strong>First, the attack surface is growing.</strong> Every organization adopting agentic AI with multi-agent orchestration is building delegation chains. MCP (Model Context Protocol) interactions, A2A (agent-to-agent) workflows, and tool-use patterns all create the multi-hop trust relationships that depend on secure token exchange.</p>

<p><strong>Second, the prerequisites are low.</strong> An attacker doesn't need to compromise the authorization server or steal signing keys. In multi-tenant agent platforms, tokens from different delegation chains are routinely available in the same environment&mdash;passed through shared message buses, cached in common token stores, or delivered via cross-agent API calls as part of normal workflows. A malicious agent doesn't need to break in. It just needs to use a token it already has access to in a context it wasn't intended for.</p>

<p><strong>Third, the implementations are moving fast.</strong> Keycloak added standard token exchange in version 26.2 (May 2025) and is working on MCP authorization support. WSO2 has delegation semantics in their Identity Server. Spring Authorization Server added token exchange in version 1.3. These are production deployments. The gap between "it works" and "it's secure against delegation-level attacks" needs to close before it's exploited.</p>

<h2>What's Being Done</h2>

<p>The mitigations are well-understood. The authorization server needs to cross-validate that the <code>subject_token</code> was intended for the actor presenting it&mdash;binding the token's audience to the actor's identity at each exchange. This needs to work alongside the <code>may_act</code> policy check, not replace it. Short token lifetimes and re-validation during token refresh limit exposure. Revocation needs to propagate through the delegation chain, not just terminate at the first hop.</p>

<p>These aren't exotic mechanisms. They're validation rules that an authorization server can enforce without changes to the token exchange protocol itself. RFC 8693 is a framework&mdash;the framework is fine. What's needed is a security profile that specifies the validation behavior implementations MUST perform when tokens participate in delegation chains.</p>

<p>The IETF draft on AI agent authorization (<a href="https://datatracker.ietf.org/doc/draft-oauth-ai-agents-on-behalf-of-user/">draft-oauth-ai-agents-on-behalf-of-user</a>) partially addresses this by binding the authorization code to the actor at the first hop. But delegation chains are typically deeper than one hop, and the binding needs to hold at every exchange, not just the initial one.</p>

<p>I'm working on a concrete mitigation profile and a conformance test methodology. More on that in a follow-up post.</p>

<h2>What You Should Do Now</h2>

<div class="callout">
<p>If you're building agentic AI systems with delegation:</p>
</div>

<ol>
  <li><strong>Audit your token exchange implementation.</strong> Does your authorization server cross-validate the <code>subject_token</code> and <code>actor_token</code>? Or does it accept any valid pair?</li>

  <li><strong>Check your <code>aud</code> claim handling.</strong> Are your delegated tokens issued with single-valued audience claims that identify the specific next actor in the chain? Multi-valued or missing audiences weaken the binding.</li>

  <li><strong>Review your refresh flow.</strong> When a delegated token is refreshed, does the authorization server re-validate the delegation context? Or does the refresh endpoint bypass the checks that the token exchange endpoint performs?</li>

  <li><strong>Watch the IETF drafts.</strong> The OAuth working group is actively addressing this. <a href="https://datatracker.ietf.org/doc/draft-oauth-ai-agents-on-behalf-of-user/">draft-oauth-ai-agents-on-behalf-of-user</a> and <a href="https://datatracker.ietf.org/doc/draft-ietf-oauth-identity-chaining/">draft-ietf-oauth-identity-chaining</a> are both relevant.</li>
</ol>

<p>The zero-trust model that Red Hat and others are advocating is the right architecture. The standards it depends on need to catch up.</p>

<div class="separator">&middot; &middot; &middot;</div>

<p class="series-note">This is Part 1 of a series on securing delegation in agentic AI systems. Part 2 will detail the validation gaps and a proposed mitigation profile. Part 3 will provide a conformance test methodology for authorization server implementations.</p>

<p class="disclosure">Disclosure: AI-powered research tools were used to assist in the initial analysis. All findings have been independently validated by the author and disclosed to the IETF OAuth working group.</p>

</article>
</body>
</html>
